import obj from './obj'

let msg = JSON.parse(JSON.stringify(obj))
msg.pt = 'Português'
msg.fr = 'Fracês'
msg.en = 'Inglês'
msg.inicio = 'Início'
msg.metodos = 'Métodos'

msg.spring_batch.annotation.EnableBatchProcessing = '@EnableBatchProcessing: injeta beans JobRepository, JobLauncher, JobRegistry, PlatformTransactionManager, JobBuilderFactory e StepBuilderFactory.'
msg.spring_batch.cdi.dataSource = '@Autowired public DataSource dataSource: objeto com informações de conexão do banco configurado em application.properties..'
msg.spring_batch.cdi.JobBuilderFactory = '@Autowired public JobBuilderFactory jobBuilderFactory: objeto que cria jobs.'
msg.spring_batch.cdi.StepBuilderFactory = '@Autowired public StepBuilderFactory stepBuilderFactory: objeto que cria steps.'
msg.spring_batch.cdi.JobLauncher = '@Autowired public JobLauncher jobLauncher: interface para executar jobs.'

msg.spring_batch.beans.JobExecutionListenerSupport = '@Bean public JobExecutionListenerSupport JobListener(): cria um novo objeto de uma classe que extende JobExecutionListenerSupport.'
msg.spring_batch.beans.StepExecutionListener = '@Bean public StepExecutionListener StepListener(): cria um novo objeto de uma classe que implementa  StepExecutionListener.'
msg.spring_batch.beans.InfoItemProcessor = '@Bean public InfoItemProcessor infoItemProcessor(): cria um novo objeto de uma classe que implementa ItemProcessor<Info, Info>'
msg.spring_batch.beans.FlatFileItemReader = '@Bean public FlatFileItemReader < Info > infoItemReader(): cria um novo objeto que lê um arquivo de texto e tranforma em objetos.'
msg.spring_batch.beans.JdbcBatchItemWriter = '@Bean public JdbcBatchItemWriter<Info> infoItemWriter(): cria um novo objeto com informaçõe para salvar informações no banco.'
msg.spring_batch.beans.infoItemStep = '@Bean public Step infoItemStep(): cria e disponibiliza um step específico.'
msg.spring_batch.beans.infoJob = '@Bean public Job infoJob(): cria e disponibiliza um job específico.'

msg.spring_batch.utiliza.JobBuilderFactory = 'utiliza: JobListener(), infoItemStep().'
msg.spring_batch.utilizado.JobBuilderFactory = 'utilizado por: infoJob().'
msg.spring_batch.utiliza.StepBuilderFactory = 'utiliza: infoItemReader(), infoItemWriter(), infoItemProcessor(), StepListener().'
msg.spring_batch.utilizado.StepBuilderFactory = 'utilizado por: infoItemStep().'
msg.spring_batch.utiliza.JobLauncher = 'utiliza: infoItemStep().'
msg.spring_batch.utilizado.JobLauncher = 'utilizado por: Exec().'
msg.spring_batch.utilizado.JobExecutionListenerSupport = 'utilizado por: JobBuilderFactory.'
msg.spring_batch.utilizado.StepExecutionListener = 'utilizado por: StepBuilderFactory.'
msg.spring_batch.utilizado.InfoItemProcessor = 'utilizado por: StepBuilderFactory.'
msg.spring_batch.utilizado.FlatFileItemReader = 'utilizado por: StepBuilderFactory.'
msg.spring_batch.utilizado.JdbcBatchItemWriter = 'utilizado por: StepBuilderFactory.'
msg.spring_batch.utilizado.infoItemStep = 'utilizado por: infoJob().'
msg.spring_batch.utilizado.infoJob = 'utilizado por: Exec().'
msg.spring_batch.utiliza.FlatFileItemReader = 'utiliza: FlatFileItemReaderBuilder<Info>.'
msg.spring_batch.utiliza.JdbcBatchItemWriter = 'utiliza: JdbcBatchItemWriterBuilder<Info>.'
msg.spring_batch.utiliza.infoItemStep = 'utiliza: StepBuilderFactory.'
msg.spring_batch.utiliza.infoJob = 'utiliza: JobBuilderFactory.'
msg.spring_batch.utiliza.execjob = 'utiliza: stepBuilderFactory, JobLauncher.'

msg.spring_batch.depende.JobLauncher = 'depende: JobParameters.'
msg.spring_batch.depende.infoItemStep = 'depende: String: nome do step, int: tamanho do chunk.'
msg.spring_batch.depende.infoJob = 'depende: String: nome do job.'
msg.spring_batch.depende.execjob = 'depende: String: nome do job, Date: parametro do job.'
msg.spring_batch.depende.jobParametersBuilder = 'depende: String: chave, Date: valor.'

msg.spring_batch.override.JobExecutionListenerSupport = '@Override public void afterJob(JobExecution jobExecution): executa após a execução do job.'
msg.spring_batch.override.StepExecutionListener_1 = '@Override public void beforeStep(StepExecution stepExecution): executa antes da execução do step.'
msg.spring_batch.override.StepExecutionListener_2 = '@Override public ExitStatus afterStep(StepExecution stepExecution): executa após a execução do step.'
msg.spring_batch.override.InfoItemProcessor = '@Override public Info process(Info item): função que tranforma / filtra o objeto de entrada e retorna um novo objeto.'

msg.spring_batch.get.execjob = '@GetMapping("/execjob") public String Exec(): endpoint que executa um job e retorna o resultado do console.'

msg.spring_batch.metodos.jobBuilderFactory.get = '.get(String): um nome único para o job.'
msg.spring_batch.metodos.jobBuilderFactory.listener = '.listener(JobExecutionListener): registra um listener para o evento de fim de execução do job.'
msg.spring_batch.metodos.jobBuilderFactory.listener = '.start(Step): um step que será executado.'
msg.spring_batch.metodos.stepBuilderFactory.get = '.get(String): um nome único para o step.'
msg.spring_batch.metodos.stepBuilderFactory.chunk = '.< Info, Info > chunk(int): método que define o tamanho do Chunck, a quantidade de registros salvos de uma vez.'
msg.spring_batch.metodos.stepBuilderFactory.reader = '.reader(infoItemReader()): registra o reader que será utilizado nesse step.'
msg.spring_batch.metodos.stepBuilderFactory.processor = '.processor((ItemProcessor<Info, Info>): registra o processor que será utilizado nesse step.'
msg.spring_batch.metodos.stepBuilderFactory.writer = '.writer(infoItemWriter()): registra o writer que será utilizado nesse step.'
msg.spring_batch.metodos.stepBuilderFactory.listener = '.listener(StepListener()): registra um listener.'
msg.spring_batch.metodos.jobLauncher.run = '.run(Job, JobParameters): executa esse job com esses parametros.'

msg.spring_batch.metodos.jobParametersBuilder.toJobParameters = '.toJobParameters(): retorna um novo JobParameters.'
msg.spring_batch.metodos.jobParametersBuilder.addDate = '.addDate(String, Date): cria novo parametro.'


msg.spring_batch.metodos.FlatFileItemReaderBuilder.name = '.name(String): nome único do reader.'
msg.spring_batch.metodos.FlatFileItemReaderBuilder.resource = '.resource(new ClassPathResource("f1.txt")): fonte para ser usado como input, ClassPathResource: caminho do arquivo em resources.'
msg.spring_batch.metodos.FlatFileItemReaderBuilder.delimited = '.delimited(): retorna um DelimitedBuilder<Info>.'
msg.spring_batch.metodos.FlatFileItemReaderBuilder.names = '.names(new String[]{ "id", "name", "CPF"}): utiliza os campos de entrada p / delimitar o texto do arquivo.'
msg.spring_batch.metodos.FlatFileItemReaderBuilder.fieldSetMapper = '.fieldSetMapper(FieldSetMapper<Info>): seta uma implementaçao FieldSetMapper: cria os objetos a partir dos nomes passados e dos valores lidos.'

msg.spring_batch.metodos.JdbcBatchItemWriterBuilder.itemSqlParameterSourceProvider = '.itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>()): extrai campos do item passado.'
msg.spring_batch.metodos.JdbcBatchItemWriterBuilder.sql = '.sql("INSERT INTO ..."): texto sql de insert.'
msg.spring_batch.metodos.JdbcBatchItemWriterBuilder.dataSource = '.dataSource(dataSource): bean dataSource injetado.'
export default msg
